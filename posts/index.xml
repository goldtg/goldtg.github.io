<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 황금호랑이'S</title><link>https://goldtg.github.io/posts/</link><description>Recent content in Posts on 황금호랑이'S</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Sat, 13 Sep 2025 20:24:06 +0900</lastBuildDate><atom:link href="https://goldtg.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>블로그 이사</title><link>https://goldtg.github.io/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EC%82%AC/</link><pubDate>Sat, 13 Sep 2025 20:24:06 +0900</pubDate><guid>https://goldtg.github.io/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EC%82%AC/</guid><description>&lt;p&gt;jekeyll, velog, hashnode 를 거쳐서 hugo로 블로그 도착!
이번에는 정말 꾸준하게 작성해보고 싶어서 좋아하는 디자인으로 선택했다&lt;/p&gt;
&lt;p&gt;기록의 중요성과 유지를 항상 원하고 있는데 미룰수록 유실되는 느낌이 들어서 반드시 이루고 말겠다는 의지!&lt;/p&gt;
&lt;p&gt;나의 커밋이 인류 발전에 아주 조금이라도 도움이 될 수 있도록 자그마한 보폭이라도 나아가자.&lt;/p&gt;</description></item><item><title>[C언어] 14.파일 시스템 이론</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-14.%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%B4%EB%A1%A0/</link><pubDate>Wed, 31 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-14.%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%B4%EB%A1%A0/</guid><description>&lt;h1 id="c언어-학습-노트--14-파일-시스템-기본-이론"&gt;C언어 학습 노트 : 14. 파일 시스템 기본 이론&lt;/h1&gt;
&lt;h2 id="1-파일-시스템의-정의"&gt;1. 파일 시스템의 정의&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;파일 시스템은 &lt;strong&gt;2차 저장장치(디스크 등)를 관리하는 방법&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;운영체제(OS)가 저장 장치에 대한 &lt;strong&gt;논리적 추상화&lt;/strong&gt;를 제공하여, 사용자는 파일 단위로 데이터를 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;파일은 프로세스가 접근 주체&lt;/strong&gt;이며, 운영체제가 접근 권한과 동시성 문제를 제어한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-파일과-입출력"&gt;2. 파일과 입출력&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;파일 오픈(open)&lt;/strong&gt; → 사용 준비.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;파일 클로즈(close)&lt;/strong&gt; → 자원 해제, 커널 테이블에서 제거.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 파일은 반드시 &lt;strong&gt;open → 작업 → close&lt;/strong&gt; 순서를 따라야 한다.&lt;/p&gt;</description></item><item><title>[C언어] 13.구조체 멤버 맞춤</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-13.%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%A9%A4%EB%B2%84%EB%A7%9E%EC%B6%A4/</link><pubDate>Tue, 30 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-13.%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%A9%A4%EB%B2%84%EB%A7%9E%EC%B6%A4/</guid><description>&lt;h1 id="c언어-학습-노트--13-구조체-멤버-맞춤"&gt;C언어 학습 노트 : 13. 구조체 멤버 맞춤&lt;/h1&gt;
&lt;h2 id="1-구조체와-메모리-배치"&gt;1. 구조체와 메모리 배치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구조체는 멤버를 단순히 이어붙이는 것이 아니라, &lt;strong&gt;정렬(Alignment)&lt;/strong&gt; 규칙에 따라 메모리에 배치된다.&lt;/li&gt;
&lt;li&gt;예를 들어 &lt;code&gt;int + char&lt;/code&gt;를 선언하면 논리적으로는 5바이트지만, 실제 구조체 크기는 8바이트가 될 수 있다.&lt;/li&gt;
&lt;li&gt;이유: CPU는 메모리를 1바이트 단위가 아니라 &lt;strong&gt;워드(word) 단위&lt;/strong&gt;로 읽는 것이 효율적이므로, 멤버가 워드 경계에 맞춰 배치된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-패딩padding과-정렬"&gt;2. 패딩(Padding)과 정렬&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구조체 내부에는 CPU 접근 효율성을 위해 &lt;strong&gt;사용하지 않는 공간(패딩)&lt;/strong&gt; 이 삽입된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구조체의 전체 크기는 &lt;strong&gt;가장 큰 멤버 크기의 배수&lt;/strong&gt;로 맞춰진다.&lt;/p&gt;</description></item><item><title>[C언어] 12.함수 응용</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-12.%ED%95%A8%EC%88%98%EC%9D%91%EC%9A%A9/</link><pubDate>Mon, 29 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-12.%ED%95%A8%EC%88%98%EC%9D%91%EC%9A%A9/</guid><description>&lt;h1 id="c언어-학습-노트--12-함수-응용"&gt;C언어 학습 노트 : 12. 함수 응용&lt;/h1&gt;
&lt;h2 id="1-매개변수-전달-방식"&gt;1. 매개변수 전달 방식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;32비트 환경(x86)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 ABI에서 &lt;strong&gt;스택&lt;/strong&gt;을 통해 인자를 전달한다.&lt;/li&gt;
&lt;li&gt;오른쪽에서 왼쪽 순서로 스택에 푸시(push)된다.&lt;/li&gt;
&lt;li&gt;호출자(caller)가 스택을 정리하는 규약(cdecl 등)과 피호출자(callee)가 정리하는 규약(stdcall 등)이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;64비트 환경(x86-64, SysV, Windows)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;주요 인자는 &lt;strong&gt;레지스터&lt;/strong&gt;로 전달된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SysV (리눅스): RDI, RSI, RDX, RCX, R8, R9 → 이후는 스택&lt;/li&gt;
&lt;li&gt;MS ABI (윈도우): RCX, RDX, R8, R9 → 이후는 스택&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나머지는 스택에 전달된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-call-by-value-값-호출"&gt;2. Call by Value (값 호출)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;함수에 &lt;strong&gt;값의 복사본&lt;/strong&gt;을 전달한다.&lt;/li&gt;
&lt;li&gt;함수 내부에서 값이 변경되어도 원본에는 영향을 주지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-call-by-reference-참조-호출"&gt;3. Call by Reference (참조 호출)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C 언어는 직접적인 참조 호출을 지원하지 않으며, &lt;strong&gt;포인터를 전달하는 방식&lt;/strong&gt;으로 구현한다.&lt;/li&gt;
&lt;li&gt;주소를 넘겨줌으로써 함수 내부에서 원본 데이터를 수정할 수 있다.&lt;/li&gt;
&lt;li&gt;설계 시 메모리 관리(수명, 해제 책임 등)를 명확히 고려해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-재귀-호출"&gt;4. 재귀 호출&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;함수가 자기 자신을 호출하는 구조.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기저 조건(base case)&lt;/strong&gt; 을 반드시 명시하여 무한 재귀에 빠지지 않도록 해야 한다.&lt;/li&gt;
&lt;li&gt;재귀 호출은 스택 프레임을 계속 쌓기 때문에, 깊이가 깊으면 &lt;strong&gt;스택 오버플로우&lt;/strong&gt;가 발생한다.&lt;/li&gt;
&lt;li&gt;따라서 입력 크기와 재귀 깊이를 고려해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="5-스택-프레임과-지역-변수-주소-반환"&gt;5. 스택 프레임과 지역 변수 주소 반환&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;함수 호출 시 스택 프레임에는 반환 주소, 매개변수, 지역 변수가 저장된다.&lt;/li&gt;
&lt;li&gt;함수가 종료되면 스택 프레임은 해제(pop)되며, 지역 변수의 주소는 더 이상 유효하지 않다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;strong&gt;지역 변수의 주소를 반환하면 정의되지 않은 동작(UB)&lt;/strong&gt; 이 발생한다.&lt;/li&gt;
&lt;li&gt;스택 메모리는 해제되지만 값이 즉시 덮어씌워지는 것은 아니므로, &amp;ldquo;쓰레기 값&amp;quot;이 남아 보이는 문제가 생길 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="6-메모리-동적-할당과-관리-이슈"&gt;6. 메모리 동적 할당과 관리 이슈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt;으로 메모리를 할당하고 &lt;code&gt;free&lt;/code&gt;로 해제하는 책임을 &lt;strong&gt;누가 가지는지&lt;/strong&gt; 호출자와 피호출자 간 명확히 정의해야 한다.&lt;/li&gt;
&lt;li&gt;함수가 메모리를 할당하여 반환한다면, 이를 받은 쪽에서 해제해야 한다.&lt;/li&gt;
&lt;li&gt;반대로 호출자가 메모리를 할당해 전달하면, 함수는 그 안에서만 사용하고 해제는 하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문서화&lt;/strong&gt;와 &lt;strong&gt;명확한 인터페이스 정의&lt;/strong&gt;가 필수적이다.&lt;/li&gt;
&lt;li&gt;또한 메모리 크기를 알 수 없는 경우 사고가 발생할 수 있으므로, 크기도 함께 전달하는 것이 안전하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="7-스택-프레임-손상-문제"&gt;7. 스택 프레임 손상 문제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C 언어에서는 버퍼 오버플로우가 발생할 수 있다.&lt;/p&gt;</description></item><item><title>[C언어] 11.메모리와 포인터</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-11.%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80_%ED%8F%AC%EC%9D%B8%ED%84%B0/</link><pubDate>Sun, 28 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-11.%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80_%ED%8F%AC%EC%9D%B8%ED%84%B0/</guid><description>&lt;h1 id="c언어-학습-노트--11-메모리와-포인터"&gt;C언어 학습 노트 : 11. 메모리와 포인터&lt;/h1&gt;
&lt;h2 id="1-메모리-종류프로세스-관점"&gt;1. 메모리 종류(프로세스 관점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stack(스택)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 호출 시 생성되는 자동 변수 저장. LIFO.&lt;/li&gt;
&lt;li&gt;각 스레드마다 독립 스택이 생성된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Heap(힙)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동적 할당 영역. &lt;code&gt;malloc/calloc/realloc/free&lt;/code&gt;로 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;실행 코드/데이터(이미지 섹션)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Text(Code) section&lt;/strong&gt;: 기계어 코드. 실행 전용.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RO Data&lt;/strong&gt;: 변경 불가 상수(문자열 리터럴 등).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RW Data / BSS&lt;/strong&gt;: 전역/정적 변수의 초기화된/미초기화 구역(정적 저장 영역).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;주의&lt;/em&gt;: Windows는 PE, 리눅스/유닉스는 ELF 형식이 일반적이나, 개념(코드/데이터/정적 영역) 자체는 유사하다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="2-가상-메모리"&gt;2. 가상 메모리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;가상 메모리는 “RAM + 디스크를 이어붙인다”라기보다, &lt;strong&gt;각 프로세스에 연속적인 가상 주소 공간을 제공하고 이를 물리 메모리/백킹 스토어에 매핑&lt;/strong&gt;하는 추상화이다.&lt;/li&gt;
&lt;li&gt;스택/힙/코드/데이터 모두 &lt;strong&gt;프로세스의 가상 주소 공간&lt;/strong&gt; 안에 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-정적-영역"&gt;3. 정적 영역&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;전역 변수&lt;/strong&gt;, &lt;strong&gt;정적 지역 변수(&lt;code&gt;static&lt;/code&gt;)&lt;/strong&gt;, &lt;strong&gt;문자열 리터럴(보통 RO)&lt;/strong&gt; 이 여기에 위치한다.&lt;/li&gt;
&lt;li&gt;수명은 프로그램 시작부터 종료까지이다(정적 저장 기간).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-실행-코드-구조"&gt;4. 실행 코드 구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행 파일은 &lt;strong&gt;여러 섹션&lt;/strong&gt;(code, rodata, data, bss 등)으로 구분되며,
섹션별 보호 속성(실행/읽기/쓰기)이 다르고 메모리 배치도 구분되어 로드된다.&lt;/li&gt;
&lt;li&gt;(그림을 넣을 계획이라면: “Text → RO Data → Data/BSS → Heap → … ← Stack” 순의 개략도 권장)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="5-포인터-변수"&gt;5. 포인터 변수&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;포인터는 &lt;strong&gt;주소를 저장하는 변수&lt;/strong&gt;이다. 포인터 자체의 값은 “어디를 가리키는가”를 의미한다.&lt;/li&gt;
&lt;li&gt;포인터가 가리키는 대상의 저장 위치는 &lt;strong&gt;스택/힙/정적&lt;/strong&gt; 어느 곳이든 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="6-포인터와-1차원-배열"&gt;6. 포인터와 1차원 배열&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;배열은 포인터가 아니다.&lt;/strong&gt; 다만 대부분의 식에서 &lt;strong&gt;배열 이름이 “첫 원소의 포인터”로 변환(decay)&lt;/strong&gt; 된다.&lt;/p&gt;</description></item><item><title>[C언어] 10.함수 이론</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-10.%ED%95%A8%EC%88%98%EC%9D%B4%EB%A1%A0/</link><pubDate>Sat, 27 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-10.%ED%95%A8%EC%88%98%EC%9D%B4%EB%A1%A0/</guid><description>&lt;h1 id="c언어-학습-노트--10-함수-이론"&gt;C언어 학습 노트 : 10. 함수 이론&lt;/h1&gt;
&lt;h2 id="1-기본-용어"&gt;1. 기본 용어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Caller (호출자)&lt;/strong&gt; : 다른 함수를 호출하는 함수.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Callee (피호출자)&lt;/strong&gt; : 호출되는 함수.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;파라미터(매개변수)&lt;/strong&gt; : 호출자와 피호출자 사이에서 데이터를 전달하는 매개체.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;임시 결과&lt;/strong&gt; : 별도의 저장 공간에 보관하지 않으면 사라지는 계산 결과 값. 즉시 사용하지 않으면 소멸한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반환 자료형&lt;/strong&gt; : 함수가 반환하는 결과 값의 형식.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-프로그램의-시작점"&gt;2. 프로그램의 시작점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C 프로그램의 진입점(entry point)은 항상 &lt;strong&gt;&lt;code&gt;main()&lt;/code&gt; 함수&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;운영체제 및 런타임 환경이 초기화를 수행한 뒤 &lt;code&gt;main()&lt;/code&gt; 함수를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt;에서 다른 함수를 호출함으로써 프로그램이 전개된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-함수-설계-원칙"&gt;3. 함수 설계 원칙&lt;/h2&gt;
&lt;h3 id="1-무엇을-함수로-만들어야-하는가"&gt;(1) 무엇을 함수로 만들어야 하는가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UI와 기능을 분리&lt;/strong&gt;할 것. (관심사의 분리 원칙)&lt;/li&gt;
&lt;li&gt;하나의 단위 기능으로 규정할 수 있는 대상은 함수로 만들 것.&lt;/li&gt;
&lt;li&gt;불연속적으로 반복되는 코드, 재사용 가능성이 높은 코드를 함수로 분리할 것.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-코드-분할-시-고려할-요소"&gt;(2) 코드 분할 시 고려할 요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;함수 이름은 수행 기능을 직관적으로 알 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;피호출 함수에 반드시 전달해야 할 정보는 &lt;strong&gt;매개변수(parameter)&lt;/strong&gt; 로 확정한다.&lt;/li&gt;
&lt;li&gt;호출자가 반드시 받아야 하는 정보는 &lt;strong&gt;반환 자료형(return type)&lt;/strong&gt; 으로 확정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-dry-원칙-dont-repeat-yourself"&gt;4. DRY 원칙 (Don’t Repeat Yourself)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;같은 기능을 수행하는 코드를 여러 곳에 중복해서 두지 않는다.&lt;/li&gt;
&lt;li&gt;중복 코드를 함수로 추출하여 재사용하면 유지보수성과 확장성이 향상된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="5-함수-원형-선언과-컴파일"&gt;5. 함수 원형 선언과 컴파일&lt;/h2&gt;
&lt;h3 id="1-함수-원형-function-prototype"&gt;(1) 함수 원형 (Function Prototype)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;함수의 시그니처(signature)를 의미한다.&lt;/li&gt;
&lt;li&gt;원형 선언은 컴파일러에게 함수의 존재와 인터페이스(반환형, 매개변수)를 알리는 역할을 한다.&lt;/li&gt;
&lt;li&gt;보통 코드 상단이나 헤더 파일에 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-분할-컴파일"&gt;(2) 분할 컴파일&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드가 여러 파일로 나뉘어 있을 경우, 각 파일을 &lt;strong&gt;별도로 컴파일&lt;/strong&gt;한 뒤 링커(linker)가 이를 결합하여 실행 파일을 생성한다.&lt;/li&gt;
&lt;li&gt;원형 선언이 없으면 컴파일러는 함수를 알 수 없어 오류를 발생시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-헤더-파일"&gt;(3) 헤더 파일&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여러 함수 원형 선언을 모아 둔 파일이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#include&lt;/code&gt;를 통해 다른 소스 파일에서 공유한다.&lt;/li&gt;
&lt;li&gt;코드 재사용성과 유지보수성을 높인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="6-변수와-저장-영역"&gt;6. 변수와 저장 영역&lt;/h2&gt;
&lt;h3 id="1-전역-변수-global-variable"&gt;(1) 전역 변수 (Global Variable)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모든 함수에서 접근 가능한 변수.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;정적 영역(static storage)&lt;/strong&gt; 에 저장된다.&lt;/li&gt;
&lt;li&gt;가급적 사용하지 않는 것이 바람직하다.&lt;/li&gt;
&lt;li&gt;식별을 위해 이름 앞에 &lt;code&gt;g_&lt;/code&gt; 접두사를 붙이는 것이 일반적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-지역-변수-local-variable"&gt;(2) 지역 변수 (Local Variable)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;특정 함수 블록 내에서 선언되어 해당 블록에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스택(stack)&lt;/strong&gt; 영역에 저장된다.&lt;/li&gt;
&lt;li&gt;블록이 끝나면 자동으로 소멸되므로 &lt;strong&gt;자동 변수(auto variable)&lt;/strong&gt; 라고도 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="7-외부-참조-extern"&gt;7. 외부 참조 (extern)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;다른 소스 파일에 정의된 변수나 함수를 사용하기 위해 &lt;code&gt;extern&lt;/code&gt; 키워드를 붙인다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt;은 &lt;strong&gt;external linkage&lt;/strong&gt;를 명시하며, 링커가 다른 파일의 정의를 연결한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// file1.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; g_value &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// file2.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;extern&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; g_value; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;printf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;%d&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;, g_value); &lt;span style="color:#75715e"&gt;// 다른 파일에 정의된 변수 사용
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="학습-포인트-정리"&gt;학습 포인트 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Caller / Callee&lt;/strong&gt; 개념은 함수 호출 관계를 명확히 구분한다.&lt;/li&gt;
&lt;li&gt;함수는 &lt;strong&gt;매개변수(입력) → 처리 → 반환 값(출력)&lt;/strong&gt; 구조를 가진다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt;은 프로그램의 진입점이며, 운영체제에 의해 호출된다.&lt;/li&gt;
&lt;li&gt;함수 설계는 UI와 기능 분리, 단일 기능 분리, DRY 원칙을 따라야 한다.&lt;/li&gt;
&lt;li&gt;원형 선언과 헤더 파일은 분할 컴파일과 코드 관리에 필수적이다.&lt;/li&gt;
&lt;li&gt;전역 변수는 정적 영역에, 지역 변수는 스택 영역에 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt;을 통해 외부 파일의 정의를 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[C언어] 9.배열을 활용한 프로그래밍</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-9.%EB%B0%B0%EC%97%B4_%ED%99%9C%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link><pubDate>Fri, 26 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-9.%EB%B0%B0%EC%97%B4_%ED%99%9C%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid><description>&lt;h1 id="c언어-학습-노트--9-배열-활용-프로그래밍"&gt;C언어 학습 노트 : 9. 배열 활용 프로그래밍&lt;/h1&gt;
&lt;h2 id="1-정렬-알고리즘"&gt;1. 정렬 알고리즘&lt;/h2&gt;
&lt;h3 id="1-버블-정렬-bubble-sort"&gt;(1) 버블 정렬 (Bubble Sort)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인접한 두 원소를 비교하여 필요할 때마다 교환한다.&lt;/li&gt;
&lt;li&gt;한 번의 반복이 끝나면 가장 큰 원소가 배열의 끝으로 이동한다.&lt;/li&gt;
&lt;li&gt;마치 거품이 위로 올라가듯 큰 값이 뒤쪽으로 모인다.&lt;/li&gt;
&lt;li&gt;시간 복잡도: O(n²)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-선택-정렬-selection-sort"&gt;(2) 선택 정렬 (Selection Sort)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배열에서 최소(또는 최대) 원소를 찾아 맨 앞(또는 맨 뒤)과 교환한다.&lt;/li&gt;
&lt;li&gt;한 번의 반복에서 교환은 한 번만 이루어진다.&lt;/li&gt;
&lt;li&gt;구현이 단순하나, 역시 O(n²) 시간 복잡도를 가진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="3-효율성-비교"&gt;(3) 효율성 비교&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;두 알고리즘 모두 구현이 쉽지만, 데이터 크기가 커질수록 비효율적이다.&lt;/li&gt;
&lt;li&gt;실제로는 퀵정렬, 병합정렬, 힙정렬과 같은 알고리즘이 더 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-배열을-활용한-핵심-프로그래밍-기법"&gt;2. 배열을 활용한 핵심 프로그래밍 기법&lt;/h2&gt;
&lt;h3 id="1-보수를-이용한-인덱스-전개"&gt;(1) 보수를 이용한 인덱스 전개&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;역순으로 접근할 때 &lt;code&gt;arr[n-1-j]&lt;/code&gt; 형태로 작성한다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;12345&lt;/code&gt; → &lt;code&gt;54321&lt;/code&gt; 변환 시 &lt;code&gt;arr[n-1-j]&lt;/code&gt;를 활용.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-flag-기법"&gt;(2) Flag 기법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flag&lt;/code&gt; 변수를 두어 흐름을 제어한다.&lt;/p&gt;</description></item><item><title>[C언어] 8.배열</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-8.%EB%B0%B0%EC%97%B4/</link><pubDate>Thu, 25 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-8.%EB%B0%B0%EC%97%B4/</guid><description>&lt;h1 id="c언어-학습-노트--8-배열"&gt;C언어 학습 노트 : 8. 배열&lt;/h1&gt;
&lt;h2 id="1-배열의-개념"&gt;1. 배열의 개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;배열은 같은 자료형의 원소들을 연속적으로 저장한 집합체이다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;int a[5];&lt;/code&gt; → &lt;code&gt;int&lt;/code&gt;형 원소가 5개 저장된 고정 길이 배열.&lt;/li&gt;
&lt;li&gt;배열 이름은 일반적으로 배열의 첫 번째 원소 주소로 해석된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr + 1&lt;/code&gt;은 다음 원소의 주소를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i]&lt;/code&gt;는 &lt;code&gt;*(arr + i)&lt;/code&gt;와 동일하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-배열-이름과-주소"&gt;2. 배열 이름과 주소&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;배열 이름 자체는 상수 포인터처럼 취급된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr&lt;/code&gt; → 배열의 첫 번째 원소 주소 (&lt;code&gt;int*&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;arr&lt;/code&gt; → 배열 전체의 주소 (&lt;code&gt;int (*)[n]&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;arr&lt;/code&gt;와 &lt;code&gt;&amp;amp;arr&lt;/code&gt;는 같은 값을 가리키지만, 의미와 자료형이 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-2차원-배열"&gt;3. 2차원 배열&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2차원 배열은 배열의 배열로, 행렬을 표현하는 데 사용된다.&lt;/li&gt;
&lt;li&gt;메모리 상에서는 1차원 선형 구조로 저장된다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;int a[2][3];&lt;/code&gt; → 실제 메모리 배치는 &lt;code&gt;a[0][0], a[0][1], a[0][2], a[1][0], …&lt;/code&gt; 순서로 이어진다.&lt;/li&gt;
&lt;li&gt;인덱스 계산은 안쪽 인덱스(열)를 먼저 증가시키고, 그다음 바깥 인덱스(행)가 증가한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-문자열과-null-종료"&gt;4. 문자열과 NULL 종료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문자열은 &lt;code&gt;char&lt;/code&gt; 배열에 저장되며, 마지막에 NULL 문자(&lt;code&gt;'\0'&lt;/code&gt;)로 종료를 표시한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\0&lt;/code&gt;은 문자열의 끝을 나타내어, 실제 길이를 가변적으로 판단할 수 있게 한다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;&amp;quot;Hello&amp;quot;&lt;/code&gt; → 메모리에는 &lt;code&gt;['H','e','l','l','o','\0']&lt;/code&gt; 로 저장된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="5-변수와-자료형"&gt;5. 변수와 자료형&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;변수는 이름, 메모리 주소, 값의 세 요소로 구성된다.&lt;/p&gt;</description></item><item><title>[C언어] 7.반복문</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-7.%EB%B0%98%EB%B3%B5%EB%AC%B8/</link><pubDate>Wed, 24 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-7.%EB%B0%98%EB%B3%B5%EB%AC%B8/</guid><description>&lt;h1 id="c언어-학습-노트--7-반복문"&gt;C언어 학습 노트 : 7. 반복문&lt;/h1&gt;
&lt;h2 id="1-while문"&gt;1. &lt;code&gt;while&lt;/code&gt;문&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (&lt;span style="color:#960050;background-color:#1e0010"&gt;조건&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;실행문&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;마무리&lt;/span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;연산&lt;/span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;조건을 먼저 평가한 뒤, 참이면 반복을 수행한다.&lt;/li&gt;
&lt;li&gt;반복 전에 조건 검사를 하기 때문에, 조건이 거짓이라면 한 번도 실행되지 않을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조건의 성립 여부&lt;/strong&gt;가 중요한 경우에 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-for문"&gt;2. &lt;code&gt;for&lt;/code&gt;문&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; (i &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; i &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;; i&lt;span style="color:#f92672"&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;실행문&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;초기식, 조건식, 증감식을 한 줄에 모아 작성할 수 있어 반복의 흐름을 한눈에 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;반복 횟수가 명확히 정해져 있을 때 가장 적합하다.&lt;/li&gt;
&lt;li&gt;초기식, 조건식, 증감식은 모두 선택적으로 생략할 수 있으며, &lt;code&gt;for(;;)&lt;/code&gt;는 무한 루프를 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-do-while문"&gt;3. &lt;code&gt;do-while&lt;/code&gt;문&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;실행문&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;} &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (&lt;span style="color:#960050;background-color:#1e0010"&gt;조건&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;먼저 실행문을 &lt;strong&gt;무조건 한 번 실행&lt;/strong&gt;한 뒤, 조건을 검사한다.&lt;/li&gt;
&lt;li&gt;조건이 참이면 다시 반복하고, 거짓이면 종료한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;과 달리 반드시 한 번은 실행된다는 점이 특징이다.&lt;/li&gt;
&lt;li&gt;문법적으로 &lt;code&gt;while(조건)&lt;/code&gt; 뒤에 세미콜론(&lt;code&gt;;&lt;/code&gt;)을 반드시 붙여야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-break와-continue"&gt;4. &lt;code&gt;break&lt;/code&gt;와 &lt;code&gt;continue&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;두 문법 모두 반복문 내에서 흐름을 제어한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="1-break"&gt;(1) &lt;code&gt;break&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;반복문을 즉시 종료하고, 반복문 다음 절차로 이동한다.&lt;/li&gt;
&lt;li&gt;보통 &lt;strong&gt;조건을 만족하면 루프를 탈출&lt;/strong&gt;하는 용도로 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-continue"&gt;(2) &lt;code&gt;continue&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 반복을 중단하고, 반복문의 조건 검사 단계로 돌아가 다음 반복을 수행한다.&lt;/li&gt;
&lt;li&gt;반복 자체를 탈출하는 것이 아니라 &lt;strong&gt;이번 반복만 건너뛴다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;흐름을 복잡하게 만들 수 있으므로, 가급적 단순한 경우에만 사용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="학습-포인트-정리"&gt;학습 포인트 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;while문&lt;/strong&gt;: 조건 중심 반복, 조건이 거짓이면 1회도 실행되지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for문&lt;/strong&gt;: 반복 횟수가 명확할 때 사용하며, 초기식·조건식·증감식이 한 줄에 있어 가독성이 높다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;do-while문&lt;/strong&gt;: 최소 1회 실행이 보장되며, 조건 뒤에 세미콜론이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;break&lt;/strong&gt;는 반복문을 종료하고, &lt;strong&gt;continue&lt;/strong&gt;는 현재 반복만 건너뛰고 다음 반복을 이어간다.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[C언어] 6.제어문</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-6.%EC%A0%9C%EC%96%B4%EB%AC%B8/</link><pubDate>Tue, 23 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-6.%EC%A0%9C%EC%96%B4%EB%AC%B8/</guid><description>&lt;h1 id="c언어-학습-노트--6-제어문"&gt;C언어 학습 노트 : 6. 제어문&lt;/h1&gt;
&lt;h2 id="1-프로그래밍과-제어-구조"&gt;1. 프로그래밍과 제어 구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍은 절차적인 흐름을 논리적으로 작성하는 과정이다.&lt;/li&gt;
&lt;li&gt;일상적인 행위(예: 기상 → 양치 → 식사)에서도 조건에 따라 분기점이 발생한다.&lt;/li&gt;
&lt;li&gt;이러한 분기점을 &lt;strong&gt;제어문(control statement)&lt;/strong&gt; 으로 표현하며, 제어문은 논리적 판단과 조건을 필요로 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-if문"&gt;2. &lt;code&gt;if&lt;/code&gt;문&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조건식의 참/거짓에 따라 분기를 수행하는 가장 기본적인 제어문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;중첩 if문&lt;/strong&gt;은 가독성과 성능 측면에서 불리할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하다면 2분할(else if 구조 등)로 단순화하는 것이 바람직하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단, 현대 CPU와 컴파일러 최적화는 상당히 발달해 있으므로, “성능”보다는 &lt;strong&gt;가독성과 유지보수성&lt;/strong&gt;을 우선적으로 고려하는 것이 좋다.&lt;/p&gt;</description></item><item><title>[C언어] 5.연산자응용</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-5.%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%91%EC%9A%A9/</link><pubDate>Mon, 22 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-5.%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%91%EC%9A%A9/</guid><description>&lt;h1 id="c언어-학습-노트--5-연산자-응용"&gt;C언어 학습 노트 : 5. 연산자 응용&lt;/h1&gt;
&lt;h2 id="1-sizeof-연산자"&gt;1. &lt;code&gt;sizeof&lt;/code&gt; 연산자&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;는 피연산자의 크기를 바이트 단위로 반환한다.&lt;/li&gt;
&lt;li&gt;대부분의 경우 &lt;strong&gt;컴파일 타임&lt;/strong&gt;에 계산되므로 CPU 부하가 발생하지 않는다.&lt;/li&gt;
&lt;li&gt;단, &lt;strong&gt;가변 길이 배열(VLA)&lt;/strong&gt; 의 경우 런타임에 계산이 수행될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof(자료형)&lt;/code&gt; 형태뿐 아니라 &lt;code&gt;sizeof 변수&lt;/code&gt; 형태로도 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;유지보수성을 높여주는 대표적인 연산자이므로 적극 활용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-상등-연산과-부등-연산-부동소수점-비교"&gt;2. 상등 연산과 부등 연산 (부동소수점 비교)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;부동소수점(float, double)은 &lt;strong&gt;근사값&lt;/strong&gt;으로 저장되므로 &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; 비교는 신뢰할 수 없다.&lt;/li&gt;
&lt;li&gt;따라서 직접적인 상등/부등 연산은 권장되지 않는다.&lt;/li&gt;
&lt;li&gt;대소 비교(&lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;)는 가능하나, 여전히 정밀도 문제를 고려해야 한다.&lt;/li&gt;
&lt;li&gt;일반적으로는 &lt;strong&gt;허용 오차(epsilon) 방식&lt;/strong&gt;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;fabs&lt;/span&gt;(a &lt;span style="color:#f92672"&gt;-&lt;/span&gt; b) &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1e-6&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// a와 b는 사실상 같은 값으로 본다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="3-논리-연산자와-short-circuit"&gt;3. 논리 연산자와 Short Circuit&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;논리 연산에서는 필요하지 않은 연산을 생략하는 &lt;strong&gt;단락 평가(short circuit)&lt;/strong&gt; 가 수행된다.&lt;/p&gt;</description></item><item><title>[C언어] 4.연산자기초</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-4.%EC%97%B0%EC%82%B0%EC%9E%90%EA%B8%B0%EC%B4%88/</link><pubDate>Sun, 21 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-4.%EC%97%B0%EC%82%B0%EC%9E%90%EA%B8%B0%EC%B4%88/</guid><description>&lt;h1 id="c언어-학습-노트--4-연산자-기초"&gt;C언어 학습 노트 : 4. 연산자 기초&lt;/h1&gt;
&lt;h2 id="1-대입-연산자-"&gt;1. 대입 연산자 (&lt;code&gt;=&lt;/code&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 복사한다.&lt;/li&gt;
&lt;li&gt;기존 값은 덮어쓰기(overwrite) 되므로, 원래의 값은 보존되지 않는다.&lt;/li&gt;
&lt;li&gt;즉, &lt;code&gt;=&lt;/code&gt; 연산은 &lt;strong&gt;Copy &amp;amp; Overwrite&lt;/strong&gt; 과정임을 반드시 인식해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-l-value와-r-value"&gt;2. l-value와 r-value&lt;/h2&gt;
&lt;h3 id="1-l-value"&gt;(1) l-value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;l-value는 &lt;strong&gt;location value&lt;/strong&gt;의 약어로, 메모리의 주소(위치)를 가리키는 값이다.&lt;/li&gt;
&lt;li&gt;변수는 대표적인 l-value이다.&lt;/li&gt;
&lt;li&gt;l-value는 r-value로 사용할 수 있다. (예: &lt;code&gt;x = y;&lt;/code&gt;에서 &lt;code&gt;y&lt;/code&gt;는 l-value이면서 r-value 역할을 한다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-r-value"&gt;(2) r-value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;r-value는 단순히 값 자체를 의미하며, 메모리 위치를 직접 지정할 수 없다.&lt;/li&gt;
&lt;li&gt;상수나 임시 계산 결과가 r-value에 해당한다.&lt;/li&gt;
&lt;li&gt;r-value는 l-value가 될 수 없다. (예: &lt;code&gt;10 = x;&lt;/code&gt;와 같은 구문은 오류이다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-이형-자료-간-연산"&gt;3. 이형 자료 간 연산&lt;/h2&gt;
&lt;h3 id="1-int--int"&gt;(1) &lt;code&gt;int + int&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;결과는 &lt;code&gt;int&lt;/code&gt;형이다.&lt;/li&gt;
&lt;li&gt;정수 나눗셈을 수행하면 소수점 이하가 절삭되고 몫만 반환된다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;7 / 3&lt;/code&gt;은 &lt;code&gt;2&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-int--double"&gt;(2) &lt;code&gt;int / double&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서로 다른 자료형을 연산할 경우, 범위가 더 넓은 자료형으로 자동 형변환이 일어난다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;int&lt;/code&gt;가 &lt;code&gt;double&lt;/code&gt;로 변환된 후 연산이 수행되어 결과는 &lt;code&gt;double&lt;/code&gt;형이 된다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;7 / 3.0&lt;/code&gt; → &lt;code&gt;2.3333…&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-요약"&gt;4. 요약&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;대입 연산자는 &lt;strong&gt;값을 복사하여 덮어쓰는 연산&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;l-value는 메모리 위치를 의미하며 변수에 해당하고, r-value는 값 자체를 의미한다.&lt;/li&gt;
&lt;li&gt;서로 다른 자료형 연산 시, &lt;strong&gt;범위가 더 넓은 자료형으로 승격(promotion)&lt;/strong&gt; 된다.&lt;/li&gt;
&lt;li&gt;정수 나눗셈에서는 소수점 이하는 절삭되므로, 몫과 나머지를 모두 구하려면 두 번의 연산(&lt;code&gt;/, %&lt;/code&gt;)을 수행해야 한다.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[C언어] 3.표준입출력</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-3.%ED%91%9C%EC%A4%80%EC%9E%85%EC%B6%9C%EB%A0%A5/</link><pubDate>Sat, 20 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-3.%ED%91%9C%EC%A4%80%EC%9E%85%EC%B6%9C%EB%A0%A5/</guid><description>&lt;h1 id="c언어-학습-노트--3-표준-입출력"&gt;C언어 학습 노트 : 3. 표준 입출력&lt;/h1&gt;
&lt;h2 id="1-hci-인간-컴퓨터-상호작용"&gt;1. HCI (인간-컴퓨터 상호작용)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CLI (Command Line Interface)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;텍스트 명령어를 통해 사용자와 컴퓨터가 상호작용하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GUI (Graphical User Interface)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그래픽 요소를 활용하여 사용자와 컴퓨터가 상호작용하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-주요-함수"&gt;2. 주요 함수&lt;/h2&gt;
&lt;h3 id="1-getchar"&gt;(1) &lt;code&gt;getchar()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한 문자를 입력받는 함수이다.&lt;/li&gt;
&lt;li&gt;입력은 버퍼(buffer)를 거쳐 처리된다.&lt;/li&gt;
&lt;li&gt;버퍼가 비어 있으면 입력을 기다리고, 버퍼에 데이터가 있으면 첫 번째 문자 하나만 반환한다.&lt;/li&gt;
&lt;li&gt;반환값은 &lt;code&gt;int&lt;/code&gt;형으로, &lt;code&gt;EOF&lt;/code&gt; 처리를 위해 &lt;code&gt;char&lt;/code&gt;가 아닌 &lt;code&gt;int&lt;/code&gt;로 정의된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;printf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;문자를 입력하세요: &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getchar&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;printf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;입력한 문자: %c&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;, c);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id="2-scanf"&gt;(2) &lt;code&gt;scanf()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서식 지정자(format specifier)에 맞추어 입력을 받는 함수이다.&lt;/p&gt;</description></item><item><title>[C언어] 2.자료형</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-2.%EC%9E%90%EB%A3%8C%ED%98%95/</link><pubDate>Fri, 19 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-2.%EC%9E%90%EB%A3%8C%ED%98%95/</guid><description>&lt;h1 id="c언어-학습-노트--자료형-정리"&gt;C언어 학습 노트 : 자료형 정리&lt;/h1&gt;
&lt;h2 id="1-정수형-자료형"&gt;1. 정수형 자료형&lt;/h2&gt;
&lt;h3 id="1-int"&gt;(1) &lt;code&gt;int&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32비트 체계에서 일반적으로 4바이트(32비트)를 차지한다.&lt;/li&gt;
&lt;li&gt;표현 범위는 약 -2,147,483,648 ~ 2,147,483,647이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-long-long-int"&gt;(2) &lt;code&gt;long long int&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;64비트 정수형으로, 8바이트(64비트)를 차지한다.&lt;/li&gt;
&lt;li&gt;표현 범위는 약 -9 × 10¹⁸ ~ 9 × 10¹⁸이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-부호signedunsigned"&gt;(3) 부호(signed/unsigned)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;signed&lt;/strong&gt; : 부호 비트가 존재하여 양수와 음수를 모두 표현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsigned&lt;/strong&gt; : 부호 비트가 없으며, 0 이상의 정수만 표현한다.
→ 같은 크기의 메모리를 사용할 경우, unsigned 형식이 더 큰 양수 범위를 표현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-문자열"&gt;2. 문자열&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문자열은 문자들의 연속이며, 마지막에 &lt;strong&gt;NULL 문자(&lt;code&gt;'\0'&lt;/code&gt;)&lt;/strong&gt; 로 끝을 표시한다.&lt;/li&gt;
&lt;li&gt;문자열을 다룰 때는 NULL 문자를 포함한 크기를 반드시 고려해야 한다.
예를 들어, 14글자를 저장하려면 15칸의 메모리를 확보해야 한다.&lt;/li&gt;
&lt;li&gt;문자열 처리 시에는 메모리 구조와 NULL 종료 규칙을 정확히 이해해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-부동소수점-자료형"&gt;3. 부동소수점 자료형&lt;/h2&gt;
&lt;h3 id="1-float"&gt;(1) &lt;code&gt;float&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단정도(single precision) 부동소수점&lt;/li&gt;
&lt;li&gt;4바이트(32비트) 크기&lt;/li&gt;
&lt;li&gt;유효 자릿수: 약 6자리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-double"&gt;(2) &lt;code&gt;double&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배정도(double precision) 부동소수점&lt;/li&gt;
&lt;li&gt;8바이트(64비트) 크기&lt;/li&gt;
&lt;li&gt;유효 자릿수: 약 15자리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-long-double"&gt;(3) &lt;code&gt;long double&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;특수 정밀도(extended precision) 부동소수점&lt;/li&gt;
&lt;li&gt;일부 컴파일러에서는 80비트(79비트 이상) 지원&lt;/li&gt;
&lt;li&gt;컴파일러와 아키텍처에 따라 지원 여부와 크기가 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4-실수의-오차-문제"&gt;(4) 실수의 오차 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터에서 실수(real number)는 근사값으로 저장되므로 오차가 발생한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;는 정밀도가 낮아 계산 시 오차가 커질 수 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 &lt;code&gt;double&lt;/code&gt;을 사용하는 것이 안전하다. 단, &lt;code&gt;double&lt;/code&gt; 역시 약 15자리까지만 정확하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-입출력-시-주의사항"&gt;4. 입출력 시 주의사항&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;printf()&lt;/code&gt;에서는 &lt;code&gt;%f&lt;/code&gt;를 사용하면 &lt;code&gt;float&lt;/code&gt;과 &lt;code&gt;double&lt;/code&gt; 모두 출력 가능하다.&lt;/p&gt;</description></item><item><title>[C언어] 1.기초</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-1.%EA%B8%B0%EC%B4%88/</link><pubDate>Thu, 18 Jan 2024 22:42:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-1.%EA%B8%B0%EC%B4%88/</guid><description>&lt;h1 id="c언어-학습-정리"&gt;C언어 학습 정리&lt;/h1&gt;
&lt;h2 id="1-c언어의-기원"&gt;1. C언어의 기원&lt;/h2&gt;
&lt;p&gt;프로그래밍 언어 C는 데니스 리치(Dennis Ritchie)에 의해 창시되었다.
초기의 UNIX 운영체제는 B 언어로 작성되었으나, 이후 C 언어로 재작성되면서 그 활용 범위가 크게 확장되었다.&lt;/p&gt;
&lt;p&gt;B 언어와 C 언어의 주요 차이는 &lt;strong&gt;자료형(type system)&lt;/strong&gt; 의 도입 여부이다.
B 언어는 typeless 언어에 가까워 모든 데이터를 단일 word 단위로 처리하였으나,
C 언어는 정교한 자료형 체계와 포인터, 배열, 구조체 등을 지원함으로써 시스템 프로그래밍 언어로서의 기반을 확립하였다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-c-프로그램의-기본-구조"&gt;2. C 프로그램의 기본 구조&lt;/h2&gt;
&lt;p&gt;다음 예제는 가장 단순한 형태의 C 프로그램이다.&lt;/p&gt;</description></item></channel></rss>