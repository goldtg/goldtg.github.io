<!doctype html><html lang=ko><head><title>학습 :: goldtg-log</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://goldtg.github.io/categories/%ED%95%99%EC%8A%B5/><link rel=stylesheet href=https://goldtg.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://goldtg.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://goldtg.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://goldtg.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://goldtg.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://goldtg.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://goldtg.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://goldtg.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://goldtg.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://goldtg.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://goldtg.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://goldtg.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://goldtg.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://goldtg.github.io/style.css><link rel="shortcut icon" href=https://goldtg.github.io/favicon.png><link rel=apple-touch-icon href=https://goldtg.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta property="og:title" content="학습"><meta property="og:description" content><meta property="og:url" content="https://goldtg.github.io/categories/%ED%95%99%EC%8A%B5/"><meta property="og:site_name" content="goldtg-log"><meta property="og:image" content="https://goldtg.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/categories/%ED%95%99%EC%8A%B5/index.xml rel=alternate type=application/rss+xml title=goldtg-log><link rel=icon type=image/x-icon href=https://goldtg.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://goldtg.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://goldtg.github.io/favicon-32x32.png><link rel=apple-touch-icon sizes=180x180 href=https://goldtg.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=192x192 href=https://goldtg.github.io/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=https://goldtg.github.io/android-chrome-512x512.png></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>goldtg's terminal</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/categories>Categories</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/categories>Categories</a></li></ul></nav></header><div class=content><h1>Posts for: #학습</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-10.%ED%95%A8%EC%88%98%EC%9D%B4%EB%A1%A0/>[C언어] 10.함수 이론</a></h1><div class=post-meta><time class=post-date>2024-01-27</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--10-함수>C언어 학습 노트 : 10. 함수</h1><h2 id=1-기본-용어>1. 기본 용어</h2><ul><li><strong>Caller (호출자)</strong> : 함수를 호출하는 쪽 함수.</li><li><strong>Callee (피호출자)</strong> : 호출되는 함수.</li><li><strong>파라미터(매개변수)</strong> : 호출자와 피호출자 사이에서 데이터를 전달하는 매개체.</li><li><strong>임시 결과</strong> : 메모리에 저장되지 않고 즉시 사용 후 사라지는 값. (예: <code>a+b</code>의 계산 결과가 변수에 저장되지 않으면 임시값으로 소멸한다.)</li><li><strong>반환 자료형</strong> : 함수가 반환하는 결과 값의 자료형.</li></ul><hr><h2 id=2-프로그램의-시작점>2. 프로그램의 시작점</h2><ul><li>C 프로그램의 진입점(entry point)은 <strong><code>main()</code> 함수</strong>이다.</li><li><code>main()</code>에서 다른 함수를 호출하여 프로그램이 전개된다.</li><li>실제 실행 순서: 운영체제 → 런타임 초기화 → <code>main()</code> 호출.</li></ul><hr><h2 id=3-함수-설계-원칙>3. 함수 설계 원칙</h2><h3 id=1-무엇을-함수로-만들어야-하는가>(1) 무엇을 함수로 만들어야 하는가?</h3><ul><li><strong>UI와 기능을 분리</strong>할 것.</li><li><strong>하나의 단위 기능</strong>으로 규정할 수 있는 대상을 함수로 만들 것.</li><li><strong>재사용성</strong>이 있는 기능은 함수로 분리할 것.</li><li>불연속적으로 반복 사용되는 부분은 함수로 묶는 것이 효과적이다.</li></ul><h3 id=2-함수의-역할-정의>(2) 함수의 역할 정의</h3><ul><li>함수 이름은 수행 기능을 직관적으로 알 수 있어야 한다.</li><li>호출자가 피호출 함수에 전달해야 할 <strong>매개변수</strong>를 명확히 정의해야 한다.</li><li>피호출 함수가 호출자에게 반환해야 할 <strong>결과(반환 자료형)</strong> 를 확정해야 한다.</li></ul><hr><h2 id=4-dry-원칙-dont-repeat-yourself>4. DRY 원칙 (Don’t Repeat Yourself)</h2><ul><li>같은 기능을 수행하는 코드를 여러 곳에 두지 않는다.</li><li>중복을 제거하고 함수화하여 유지보수성을 높인다.</li></ul><hr><h2 id=학습-포인트-정리>학습 포인트 정리</h2><ul><li><strong>Caller / Callee</strong> 개념을 명확히 구분할 것.</li><li>함수는 <strong>입력(매개변수) → 처리(피호출자) → 출력(반환 값)</strong> 구조를 가진다.</li><li><code>main()</code>은 프로그램의 진입점이며, 실행 환경에 의해 호출된다.</li><li>함수 설계는 <strong>단일 기능, 재사용성, 명확한 인터페이스</strong>를 기준으로 한다.</li><li>DRY 원칙을 지켜 중복 코드를 제거하면 유지보수성이 향상된다.</li></ul></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-10.%ED%95%A8%EC%88%98%EC%9D%B4%EB%A1%A0/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-9.%EB%B0%B0%EC%97%B4_%ED%99%9C%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/>[C언어] 9.배열을 활용한 프로그래밍</a></h1><div class=post-meta><time class=post-date>2024-01-26</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--9-배열-활용-프로그래밍>C언어 학습 노트 : 9. 배열 활용 프로그래밍</h1><h2 id=1-정렬-알고리즘>1. 정렬 알고리즘</h2><h3 id=1-버블-정렬-bubble-sort>(1) 버블 정렬 (Bubble Sort)</h3><ul><li>인접한 두 원소를 비교하여 필요할 때마다 교환한다.</li><li>한 번의 반복이 끝나면 가장 큰 원소가 배열의 끝으로 이동한다.</li><li>마치 거품이 위로 올라가듯 큰 값이 뒤쪽으로 모인다.</li><li>시간 복잡도: O(n²)</li></ul><hr><h3 id=2-선택-정렬-selection-sort>(2) 선택 정렬 (Selection Sort)</h3><ul><li>배열에서 최소(또는 최대) 원소를 찾아 맨 앞(또는 맨 뒤)과 교환한다.</li><li>한 번의 반복에서 교환은 한 번만 이루어진다.</li><li>구현이 단순하나, 역시 O(n²) 시간 복잡도를 가진다.</li></ul><hr><h3 id=3-효율성-비교>(3) 효율성 비교</h3><ul><li>두 알고리즘 모두 구현이 쉽지만, 데이터 크기가 커질수록 비효율적이다.</li><li>실제로는 퀵정렬, 병합정렬, 힙정렬과 같은 알고리즘이 더 적합하다.</li></ul><hr><h2 id=2-배열을-활용한-핵심-프로그래밍-기법>2. 배열을 활용한 핵심 프로그래밍 기법</h2><h3 id=1-보수를-이용한-인덱스-전개>(1) 보수를 이용한 인덱스 전개</h3><ul><li>역순으로 접근할 때 <code>arr[n-1-j]</code> 형태로 작성한다.</li><li>예: <code>12345</code> → <code>54321</code> 변환 시 <code>arr[n-1-j]</code>를 활용.</li></ul><hr><h3 id=2-flag-기법>(2) Flag 기법</h3><ul><li><p><code>flag</code> 변수를 두어 흐름을 제어한다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-9.%EB%B0%B0%EC%97%B4_%ED%99%9C%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-8.%EB%B0%B0%EC%97%B4/>[C언어] 8.배열</a></h1><div class=post-meta><time class=post-date>2024-01-25</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--8-배열>C언어 학습 노트 : 8. 배열</h1><h2 id=1-배열의-개념>1. 배열의 개념</h2><ul><li>배열은 같은 자료형의 원소들을 연속적으로 저장한 집합체이다.</li><li>예: <code>int a[5];</code> → <code>int</code>형 원소가 5개 저장된 고정 길이 배열.</li><li>배열 이름은 일반적으로 배열의 첫 번째 원소 주소로 해석된다.</li><li><code>arr + 1</code>은 다음 원소의 주소를 의미한다.</li><li><code>arr[i]</code>는 <code>*(arr + i)</code>와 동일하다.</li></ul><hr><h2 id=2-배열-이름과-주소>2. 배열 이름과 주소</h2><ul><li>배열 이름 자체는 상수 포인터처럼 취급된다.</li><li><code>arr</code> → 배열의 첫 번째 원소 주소 (<code>int*</code>).</li><li><code>&amp;arr</code> → 배열 전체의 주소 (<code>int (*)[n]</code>).</li><li>따라서 <code>arr</code>와 <code>&amp;arr</code>는 같은 값을 가리키지만, 의미와 자료형이 다르다.</li></ul><hr><h2 id=3-2차원-배열>3. 2차원 배열</h2><ul><li>2차원 배열은 배열의 배열로, 행렬을 표현하는 데 사용된다.</li><li>메모리 상에서는 1차원 선형 구조로 저장된다.</li><li>예: <code>int a[2][3];</code> → 실제 메모리 배치는 <code>a[0][0], a[0][1], a[0][2], a[1][0], …</code> 순서로 이어진다.</li><li>인덱스 계산은 안쪽 인덱스(열)를 먼저 증가시키고, 그다음 바깥 인덱스(행)가 증가한다.</li></ul><hr><h2 id=4-문자열과-null-종료>4. 문자열과 NULL 종료</h2><ul><li>문자열은 <code>char</code> 배열에 저장되며, 마지막에 NULL 문자(<code>'\0'</code>)로 종료를 표시한다.</li><li><code>\0</code>은 문자열의 끝을 나타내어, 실제 길이를 가변적으로 판단할 수 있게 한다.</li><li>예: <code>"Hello"</code> → 메모리에는 <code>['H','e','l','l','o','\0']</code> 로 저장된다.</li></ul><hr><h2 id=5-변수와-자료형>5. 변수와 자료형</h2><ul><li><p>변수는 이름, 메모리 주소, 값의 세 요소로 구성된다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-8.%EB%B0%B0%EC%97%B4/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-7.%EB%B0%98%EB%B3%B5%EB%AC%B8/>[C언어] 7.반복문</a></h1><div class=post-meta><time class=post-date>2024-01-24</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--7-반복문>C언어 학습 노트 : 7. 반복문</h1><h2 id=1-while문>1. <code>while</code>문</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#960050;background-color:#1e0010>조건</span>) {
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>실행문</span>;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>마무리</span> <span style=color:#960050;background-color:#1e0010>연산</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>조건을 먼저 평가한 뒤, 참이면 반복을 수행한다.</li><li>반복 전에 조건 검사를 하기 때문에, 조건이 거짓이라면 한 번도 실행되지 않을 수 있다.</li><li><strong>조건의 성립 여부</strong>가 중요한 경우에 적합하다.</li></ul><hr><h2 id=2-for문>2. <code>for</code>문</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>실행문</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>초기식, 조건식, 증감식을 한 줄에 모아 작성할 수 있어 반복의 흐름을 한눈에 파악할 수 있다.</li><li>반복 횟수가 명확히 정해져 있을 때 가장 적합하다.</li><li>초기식, 조건식, 증감식은 모두 선택적으로 생략할 수 있으며, <code>for(;;)</code>는 무한 루프를 의미한다.</li></ul><hr><h2 id=3-do-while문>3. <code>do-while</code>문</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>실행문</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (<span style=color:#960050;background-color:#1e0010>조건</span>);
</span></span></code></pre></div><ul><li>먼저 실행문을 <strong>무조건 한 번 실행</strong>한 뒤, 조건을 검사한다.</li><li>조건이 참이면 다시 반복하고, 거짓이면 종료한다.</li><li><code>while</code>과 달리 반드시 한 번은 실행된다는 점이 특징이다.</li><li>문법적으로 <code>while(조건)</code> 뒤에 세미콜론(<code>;</code>)을 반드시 붙여야 한다.</li></ul><hr><h2 id=4-break와-continue>4. <code>break</code>와 <code>continue</code></h2><ul><li>두 문법 모두 반복문 내에서 흐름을 제어한다.</li></ul><h3 id=1-break>(1) <code>break</code></h3><ul><li>반복문을 즉시 종료하고, 반복문 다음 절차로 이동한다.</li><li>보통 <strong>조건을 만족하면 루프를 탈출</strong>하는 용도로 사용된다.</li></ul><h3 id=2-continue>(2) <code>continue</code></h3><ul><li>현재 반복을 중단하고, 반복문의 조건 검사 단계로 돌아가 다음 반복을 수행한다.</li><li>반복 자체를 탈출하는 것이 아니라 <strong>이번 반복만 건너뛴다</strong>.</li><li>흐름을 복잡하게 만들 수 있으므로, 가급적 단순한 경우에만 사용하는 것이 좋다.</li></ul><hr><h2 id=학습-포인트-정리>학습 포인트 정리</h2><ul><li><strong>while문</strong>: 조건 중심 반복, 조건이 거짓이면 1회도 실행되지 않는다.</li><li><strong>for문</strong>: 반복 횟수가 명확할 때 사용하며, 초기식·조건식·증감식이 한 줄에 있어 가독성이 높다.</li><li><strong>do-while문</strong>: 최소 1회 실행이 보장되며, 조건 뒤에 세미콜론이 필요하다.</li><li><strong>break</strong>는 반복문을 종료하고, <strong>continue</strong>는 현재 반복만 건너뛰고 다음 반복을 이어간다.</li></ul></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-7.%EB%B0%98%EB%B3%B5%EB%AC%B8/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-6.%EC%A0%9C%EC%96%B4%EB%AC%B8/>[C언어] 6.제어문</a></h1><div class=post-meta><time class=post-date>2024-01-23</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--6-제어문>C언어 학습 노트 : 6. 제어문</h1><h2 id=1-프로그래밍과-제어-구조>1. 프로그래밍과 제어 구조</h2><ul><li>프로그래밍은 절차적인 흐름을 논리적으로 작성하는 과정이다.</li><li>일상적인 행위(예: 기상 → 양치 → 식사)에서도 조건에 따라 분기점이 발생한다.</li><li>이러한 분기점을 <strong>제어문(control statement)</strong> 으로 표현하며, 제어문은 논리적 판단과 조건을 필요로 한다.</li></ul><hr><h2 id=2-if문>2. <code>if</code>문</h2><ul><li><p>조건식의 참/거짓에 따라 분기를 수행하는 가장 기본적인 제어문이다.</p></li><li><p><strong>중첩 if문</strong>은 가독성과 성능 측면에서 불리할 수 있다.</p><ul><li>가능하다면 2분할(else if 구조 등)로 단순화하는 것이 바람직하다.</li></ul></li><li><p>단, 현대 CPU와 컴파일러 최적화는 상당히 발달해 있으므로, “성능”보다는 <strong>가독성과 유지보수성</strong>을 우선적으로 고려하는 것이 좋다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-6.%EC%A0%9C%EC%96%B4%EB%AC%B8/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-5.%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%91%EC%9A%A9/>[C언어] 5.연산자응용</a></h1><div class=post-meta><time class=post-date>2024-01-22</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--5-연산자-응용>C언어 학습 노트 : 5. 연산자 응용</h1><h2 id=1-sizeof-연산자>1. <code>sizeof</code> 연산자</h2><ul><li><code>sizeof</code>는 피연산자의 크기를 바이트 단위로 반환한다.</li><li>대부분의 경우 <strong>컴파일 타임</strong>에 계산되므로 CPU 부하가 발생하지 않는다.</li><li>단, <strong>가변 길이 배열(VLA)</strong> 의 경우 런타임에 계산이 수행될 수 있다.</li><li><code>sizeof(자료형)</code> 형태뿐 아니라 <code>sizeof 변수</code> 형태로도 사용할 수 있다.</li><li>유지보수성을 높여주는 대표적인 연산자이므로 적극 활용하는 것이 좋다.</li></ul><hr><h2 id=2-상등-연산과-부등-연산-부동소수점-비교>2. 상등 연산과 부등 연산 (부동소수점 비교)</h2><ul><li>부동소수점(float, double)은 <strong>근사값</strong>으로 저장되므로 <code>==</code>, <code>!=</code> 비교는 신뢰할 수 없다.</li><li>따라서 직접적인 상등/부등 연산은 권장되지 않는다.</li><li>대소 비교(<code>>=</code>, <code>&lt;=</code>)는 가능하나, 여전히 정밀도 문제를 고려해야 한다.</li><li>일반적으로는 <strong>허용 오차(epsilon) 방식</strong>을 사용한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>fabs</span>(a <span style=color:#f92672>-</span> b) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1e-6</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a와 b는 사실상 같은 값으로 본다
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><h2 id=3-논리-연산자와-short-circuit>3. 논리 연산자와 Short Circuit</h2><ul><li><p>논리 연산에서는 필요하지 않은 연산을 생략하는 <strong>단락 평가(short circuit)</strong> 가 수행된다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-5.%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%91%EC%9A%A9/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-4.%EC%97%B0%EC%82%B0%EC%9E%90%EA%B8%B0%EC%B4%88/>[C언어] 4.연산자기초</a></h1><div class=post-meta><time class=post-date>2024-01-21</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--4-연산자-기초>C언어 학습 노트 : 4. 연산자 기초</h1><h2 id=1-대입-연산자->1. 대입 연산자 (<code>=</code>)</h2><ul><li>대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 복사한다.</li><li>기존 값은 덮어쓰기(overwrite) 되므로, 원래의 값은 보존되지 않는다.</li><li>즉, <code>=</code> 연산은 <strong>Copy & Overwrite</strong> 과정임을 반드시 인식해야 한다.</li></ul><hr><h2 id=2-l-value와-r-value>2. l-value와 r-value</h2><h3 id=1-l-value>(1) l-value</h3><ul><li>l-value는 <strong>location value</strong>의 약어로, 메모리의 주소(위치)를 가리키는 값이다.</li><li>변수는 대표적인 l-value이다.</li><li>l-value는 r-value로 사용할 수 있다. (예: <code>x = y;</code>에서 <code>y</code>는 l-value이면서 r-value 역할을 한다.)</li></ul><h3 id=2-r-value>(2) r-value</h3><ul><li>r-value는 단순히 값 자체를 의미하며, 메모리 위치를 직접 지정할 수 없다.</li><li>상수나 임시 계산 결과가 r-value에 해당한다.</li><li>r-value는 l-value가 될 수 없다. (예: <code>10 = x;</code>와 같은 구문은 오류이다.)</li></ul><hr><h2 id=3-이형-자료-간-연산>3. 이형 자료 간 연산</h2><h3 id=1-int--int>(1) <code>int + int</code></h3><ul><li>결과는 <code>int</code>형이다.</li><li>정수 나눗셈을 수행하면 소수점 이하가 절삭되고 몫만 반환된다.</li><li>따라서 <code>7 / 3</code>은 <code>2</code>가 된다.</li></ul><h3 id=2-int--double>(2) <code>int / double</code></h3><ul><li>서로 다른 자료형을 연산할 경우, 범위가 더 넓은 자료형으로 자동 형변환이 일어난다.</li><li>따라서 <code>int</code>가 <code>double</code>로 변환된 후 연산이 수행되어 결과는 <code>double</code>형이 된다.</li><li>예: <code>7 / 3.0</code> → <code>2.3333…</code></li></ul><hr><h2 id=4-요약>4. 요약</h2><ul><li>대입 연산자는 <strong>값을 복사하여 덮어쓰는 연산</strong>이다.</li><li>l-value는 메모리 위치를 의미하며 변수에 해당하고, r-value는 값 자체를 의미한다.</li><li>서로 다른 자료형 연산 시, <strong>범위가 더 넓은 자료형으로 승격(promotion)</strong> 된다.</li><li>정수 나눗셈에서는 소수점 이하는 절삭되므로, 몫과 나머지를 모두 구하려면 두 번의 연산(<code>/, %</code>)을 수행해야 한다.</li></ul></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-4.%EC%97%B0%EC%82%B0%EC%9E%90%EA%B8%B0%EC%B4%88/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-3.%ED%91%9C%EC%A4%80%EC%9E%85%EC%B6%9C%EB%A0%A5/>[C언어] 3.표준입출력</a></h1><div class=post-meta><time class=post-date>2024-01-20</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--3-표준-입출력>C언어 학습 노트 : 3. 표준 입출력</h1><h2 id=1-hci-인간-컴퓨터-상호작용>1. HCI (인간-컴퓨터 상호작용)</h2><ul><li><p><strong>CLI (Command Line Interface)</strong></p><ul><li>텍스트 명령어를 통해 사용자와 컴퓨터가 상호작용하는 방식이다.</li></ul></li><li><p><strong>GUI (Graphical User Interface)</strong></p><ul><li>그래픽 요소를 활용하여 사용자와 컴퓨터가 상호작용하는 방식이다.</li></ul></li></ul><hr><h2 id=2-주요-함수>2. 주요 함수</h2><h3 id=1-getchar>(1) <code>getchar()</code></h3><ul><li>한 문자를 입력받는 함수이다.</li><li>입력은 버퍼(buffer)를 거쳐 처리된다.</li><li>버퍼가 비어 있으면 입력을 기다리고, 버퍼에 데이터가 있으면 첫 번째 문자 하나만 반환한다.</li><li>반환값은 <code>int</code>형으로, <code>EOF</code> 처리를 위해 <code>char</code>가 아닌 <code>int</code>로 정의된다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;문자를 입력하세요: &#34;</span>);
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> <span style=color:#a6e22e>getchar</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;입력한 문자: %c</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=2-scanf>(2) <code>scanf()</code></h3><ul><li><p>서식 지정자(format specifier)에 맞추어 입력을 받는 함수이다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-3.%ED%91%9C%EC%A4%80%EC%9E%85%EC%B6%9C%EB%A0%A5/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-2.%EC%9E%90%EB%A3%8C%ED%98%95/>[C언어] 2.자료형</a></h1><div class=post-meta><time class=post-date>2024-01-19</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-노트--자료형-정리>C언어 학습 노트 : 자료형 정리</h1><h2 id=1-정수형-자료형>1. 정수형 자료형</h2><h3 id=1-int>(1) <code>int</code></h3><ul><li>32비트 체계에서 일반적으로 4바이트(32비트)를 차지한다.</li><li>표현 범위는 약 -2,147,483,648 ~ 2,147,483,647이다.</li></ul><h3 id=2-long-long-int>(2) <code>long long int</code></h3><ul><li>64비트 정수형으로, 8바이트(64비트)를 차지한다.</li><li>표현 범위는 약 -9 × 10¹⁸ ~ 9 × 10¹⁸이다.</li></ul><h3 id=3-부호signedunsigned>(3) 부호(signed/unsigned)</h3><ul><li><strong>signed</strong> : 부호 비트가 존재하여 양수와 음수를 모두 표현한다.</li><li><strong>unsigned</strong> : 부호 비트가 없으며, 0 이상의 정수만 표현한다.
→ 같은 크기의 메모리를 사용할 경우, unsigned 형식이 더 큰 양수 범위를 표현할 수 있다.</li></ul><hr><h2 id=2-문자열>2. 문자열</h2><ul><li>문자열은 문자들의 연속이며, 마지막에 <strong>NULL 문자(<code>'\0'</code>)</strong> 로 끝을 표시한다.</li><li>문자열을 다룰 때는 NULL 문자를 포함한 크기를 반드시 고려해야 한다.
예를 들어, 14글자를 저장하려면 15칸의 메모리를 확보해야 한다.</li><li>문자열 처리 시에는 메모리 구조와 NULL 종료 규칙을 정확히 이해해야 한다.</li></ul><hr><h2 id=3-부동소수점-자료형>3. 부동소수점 자료형</h2><h3 id=1-float>(1) <code>float</code></h3><ul><li>단정도(single precision) 부동소수점</li><li>4바이트(32비트) 크기</li><li>유효 자릿수: 약 6자리</li></ul><h3 id=2-double>(2) <code>double</code></h3><ul><li>배정도(double precision) 부동소수점</li><li>8바이트(64비트) 크기</li><li>유효 자릿수: 약 15자리</li></ul><h3 id=3-long-double>(3) <code>long double</code></h3><ul><li>특수 정밀도(extended precision) 부동소수점</li><li>일부 컴파일러에서는 80비트(79비트 이상) 지원</li><li>컴파일러와 아키텍처에 따라 지원 여부와 크기가 다르다.</li></ul><h3 id=4-실수의-오차-문제>(4) 실수의 오차 문제</h3><ul><li>컴퓨터에서 실수(real number)는 근사값으로 저장되므로 오차가 발생한다.</li><li><code>float</code>는 정밀도가 낮아 계산 시 오차가 커질 수 있다.</li><li>일반적으로 <code>double</code>을 사용하는 것이 안전하다. 단, <code>double</code> 역시 약 15자리까지만 정확하다.</li></ul><hr><h2 id=4-입출력-시-주의사항>4. 입출력 시 주의사항</h2><ul><li><p><code>printf()</code>에서는 <code>%f</code>를 사용하면 <code>float</code>과 <code>double</code> 모두 출력 가능하다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-2.%EC%9E%90%EB%A3%8C%ED%98%95/>[더보기]</a></div></article><article class="post on-list"><h1 class=post-title><a href=https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-1.%EA%B8%B0%EC%B4%88/>[C언어] 1.기초</a></h1><div class=post-meta><time class=post-date>2024-01-18</time></div><span class=post-tags>#<a href=https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/>C언어</a>&nbsp;</span><div class=post-content><h1 id=c언어-학습-정리>C언어 학습 정리</h1><h2 id=1-c언어의-기원>1. C언어의 기원</h2><p>프로그래밍 언어 C는 데니스 리치(Dennis Ritchie)에 의해 창시되었다.
초기의 UNIX 운영체제는 B 언어로 작성되었으나, 이후 C 언어로 재작성되면서 그 활용 범위가 크게 확장되었다.</p><p>B 언어와 C 언어의 주요 차이는 <strong>자료형(type system)</strong> 의 도입 여부이다.
B 언어는 typeless 언어에 가까워 모든 데이터를 단일 word 단위로 처리하였으나,
C 언어는 정교한 자료형 체계와 포인터, 배열, 구조체 등을 지원함으로써 시스템 프로그래밍 언어로서의 기반을 확립하였다.</p><hr><h2 id=2-c-프로그램의-기본-구조>2. C 프로그램의 기본 구조</h2><p>다음 예제는 가장 단순한 형태의 C 프로그램이다.</p></div><div><a class="read-more button inline" href=/posts/c%EC%96%B8%EC%96%B4-1.%EA%B8%B0%EC%B4%88/>[더보기]</a></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 goldtg - Made with ❤️ using Hugo</span>
<span>:: <a href=https://github.com/goldtg target=_blank>goldtg's GitHub</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>