<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C언어 on goldtg-log</title><link>https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/</link><description>Recent content in C언어 on goldtg-log</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Sat, 27 Jan 2024 22:54:37 +0900</lastBuildDate><atom:link href="https://goldtg.github.io/tags/c%EC%96%B8%EC%96%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>[C언어] 10.함수 이론</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-10.%ED%95%A8%EC%88%98%EC%9D%B4%EB%A1%A0/</link><pubDate>Sat, 27 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-10.%ED%95%A8%EC%88%98%EC%9D%B4%EB%A1%A0/</guid><description>&lt;h1 id="c언어-학습-노트--10-함수"&gt;C언어 학습 노트 : 10. 함수&lt;/h1&gt;
&lt;h2 id="1-기본-용어"&gt;1. 기본 용어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Caller (호출자)&lt;/strong&gt; : 함수를 호출하는 쪽 함수.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Callee (피호출자)&lt;/strong&gt; : 호출되는 함수.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;파라미터(매개변수)&lt;/strong&gt; : 호출자와 피호출자 사이에서 데이터를 전달하는 매개체.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;임시 결과&lt;/strong&gt; : 메모리에 저장되지 않고 즉시 사용 후 사라지는 값. (예: &lt;code&gt;a+b&lt;/code&gt;의 계산 결과가 변수에 저장되지 않으면 임시값으로 소멸한다.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반환 자료형&lt;/strong&gt; : 함수가 반환하는 결과 값의 자료형.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-프로그램의-시작점"&gt;2. 프로그램의 시작점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C 프로그램의 진입점(entry point)은 &lt;strong&gt;&lt;code&gt;main()&lt;/code&gt; 함수&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt;에서 다른 함수를 호출하여 프로그램이 전개된다.&lt;/li&gt;
&lt;li&gt;실제 실행 순서: 운영체제 → 런타임 초기화 → &lt;code&gt;main()&lt;/code&gt; 호출.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-함수-설계-원칙"&gt;3. 함수 설계 원칙&lt;/h2&gt;
&lt;h3 id="1-무엇을-함수로-만들어야-하는가"&gt;(1) 무엇을 함수로 만들어야 하는가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UI와 기능을 분리&lt;/strong&gt;할 것.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;하나의 단위 기능&lt;/strong&gt;으로 규정할 수 있는 대상을 함수로 만들 것.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재사용성&lt;/strong&gt;이 있는 기능은 함수로 분리할 것.&lt;/li&gt;
&lt;li&gt;불연속적으로 반복 사용되는 부분은 함수로 묶는 것이 효과적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-함수의-역할-정의"&gt;(2) 함수의 역할 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;함수 이름은 수행 기능을 직관적으로 알 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;호출자가 피호출 함수에 전달해야 할 &lt;strong&gt;매개변수&lt;/strong&gt;를 명확히 정의해야 한다.&lt;/li&gt;
&lt;li&gt;피호출 함수가 호출자에게 반환해야 할 &lt;strong&gt;결과(반환 자료형)&lt;/strong&gt; 를 확정해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-dry-원칙-dont-repeat-yourself"&gt;4. DRY 원칙 (Don’t Repeat Yourself)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;같은 기능을 수행하는 코드를 여러 곳에 두지 않는다.&lt;/li&gt;
&lt;li&gt;중복을 제거하고 함수화하여 유지보수성을 높인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="학습-포인트-정리"&gt;학습 포인트 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Caller / Callee&lt;/strong&gt; 개념을 명확히 구분할 것.&lt;/li&gt;
&lt;li&gt;함수는 &lt;strong&gt;입력(매개변수) → 처리(피호출자) → 출력(반환 값)&lt;/strong&gt; 구조를 가진다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt;은 프로그램의 진입점이며, 실행 환경에 의해 호출된다.&lt;/li&gt;
&lt;li&gt;함수 설계는 &lt;strong&gt;단일 기능, 재사용성, 명확한 인터페이스&lt;/strong&gt;를 기준으로 한다.&lt;/li&gt;
&lt;li&gt;DRY 원칙을 지켜 중복 코드를 제거하면 유지보수성이 향상된다.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[C언어] 9.배열을 활용한 프로그래밍</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-9.%EB%B0%B0%EC%97%B4_%ED%99%9C%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link><pubDate>Fri, 26 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-9.%EB%B0%B0%EC%97%B4_%ED%99%9C%EC%9A%A9_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid><description>&lt;h1 id="c언어-학습-노트--9-배열-활용-프로그래밍"&gt;C언어 학습 노트 : 9. 배열 활용 프로그래밍&lt;/h1&gt;
&lt;h2 id="1-정렬-알고리즘"&gt;1. 정렬 알고리즘&lt;/h2&gt;
&lt;h3 id="1-버블-정렬-bubble-sort"&gt;(1) 버블 정렬 (Bubble Sort)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인접한 두 원소를 비교하여 필요할 때마다 교환한다.&lt;/li&gt;
&lt;li&gt;한 번의 반복이 끝나면 가장 큰 원소가 배열의 끝으로 이동한다.&lt;/li&gt;
&lt;li&gt;마치 거품이 위로 올라가듯 큰 값이 뒤쪽으로 모인다.&lt;/li&gt;
&lt;li&gt;시간 복잡도: O(n²)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-선택-정렬-selection-sort"&gt;(2) 선택 정렬 (Selection Sort)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배열에서 최소(또는 최대) 원소를 찾아 맨 앞(또는 맨 뒤)과 교환한다.&lt;/li&gt;
&lt;li&gt;한 번의 반복에서 교환은 한 번만 이루어진다.&lt;/li&gt;
&lt;li&gt;구현이 단순하나, 역시 O(n²) 시간 복잡도를 가진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="3-효율성-비교"&gt;(3) 효율성 비교&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;두 알고리즘 모두 구현이 쉽지만, 데이터 크기가 커질수록 비효율적이다.&lt;/li&gt;
&lt;li&gt;실제로는 퀵정렬, 병합정렬, 힙정렬과 같은 알고리즘이 더 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-배열을-활용한-핵심-프로그래밍-기법"&gt;2. 배열을 활용한 핵심 프로그래밍 기법&lt;/h2&gt;
&lt;h3 id="1-보수를-이용한-인덱스-전개"&gt;(1) 보수를 이용한 인덱스 전개&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;역순으로 접근할 때 &lt;code&gt;arr[n-1-j]&lt;/code&gt; 형태로 작성한다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;12345&lt;/code&gt; → &lt;code&gt;54321&lt;/code&gt; 변환 시 &lt;code&gt;arr[n-1-j]&lt;/code&gt;를 활용.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-flag-기법"&gt;(2) Flag 기법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flag&lt;/code&gt; 변수를 두어 흐름을 제어한다.&lt;/p&gt;</description></item><item><title>[C언어] 8.배열</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-8.%EB%B0%B0%EC%97%B4/</link><pubDate>Thu, 25 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-8.%EB%B0%B0%EC%97%B4/</guid><description>&lt;h1 id="c언어-학습-노트--8-배열"&gt;C언어 학습 노트 : 8. 배열&lt;/h1&gt;
&lt;h2 id="1-배열의-개념"&gt;1. 배열의 개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;배열은 같은 자료형의 원소들을 연속적으로 저장한 집합체이다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;int a[5];&lt;/code&gt; → &lt;code&gt;int&lt;/code&gt;형 원소가 5개 저장된 고정 길이 배열.&lt;/li&gt;
&lt;li&gt;배열 이름은 일반적으로 배열의 첫 번째 원소 주소로 해석된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr + 1&lt;/code&gt;은 다음 원소의 주소를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i]&lt;/code&gt;는 &lt;code&gt;*(arr + i)&lt;/code&gt;와 동일하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-배열-이름과-주소"&gt;2. 배열 이름과 주소&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;배열 이름 자체는 상수 포인터처럼 취급된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr&lt;/code&gt; → 배열의 첫 번째 원소 주소 (&lt;code&gt;int*&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;arr&lt;/code&gt; → 배열 전체의 주소 (&lt;code&gt;int (*)[n]&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;arr&lt;/code&gt;와 &lt;code&gt;&amp;amp;arr&lt;/code&gt;는 같은 값을 가리키지만, 의미와 자료형이 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-2차원-배열"&gt;3. 2차원 배열&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2차원 배열은 배열의 배열로, 행렬을 표현하는 데 사용된다.&lt;/li&gt;
&lt;li&gt;메모리 상에서는 1차원 선형 구조로 저장된다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;int a[2][3];&lt;/code&gt; → 실제 메모리 배치는 &lt;code&gt;a[0][0], a[0][1], a[0][2], a[1][0], …&lt;/code&gt; 순서로 이어진다.&lt;/li&gt;
&lt;li&gt;인덱스 계산은 안쪽 인덱스(열)를 먼저 증가시키고, 그다음 바깥 인덱스(행)가 증가한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-문자열과-null-종료"&gt;4. 문자열과 NULL 종료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문자열은 &lt;code&gt;char&lt;/code&gt; 배열에 저장되며, 마지막에 NULL 문자(&lt;code&gt;'\0'&lt;/code&gt;)로 종료를 표시한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\0&lt;/code&gt;은 문자열의 끝을 나타내어, 실제 길이를 가변적으로 판단할 수 있게 한다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;&amp;quot;Hello&amp;quot;&lt;/code&gt; → 메모리에는 &lt;code&gt;['H','e','l','l','o','\0']&lt;/code&gt; 로 저장된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="5-변수와-자료형"&gt;5. 변수와 자료형&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;변수는 이름, 메모리 주소, 값의 세 요소로 구성된다.&lt;/p&gt;</description></item><item><title>[C언어] 7.반복문</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-7.%EB%B0%98%EB%B3%B5%EB%AC%B8/</link><pubDate>Wed, 24 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-7.%EB%B0%98%EB%B3%B5%EB%AC%B8/</guid><description>&lt;h1 id="c언어-학습-노트--7-반복문"&gt;C언어 학습 노트 : 7. 반복문&lt;/h1&gt;
&lt;h2 id="1-while문"&gt;1. &lt;code&gt;while&lt;/code&gt;문&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (&lt;span style="color:#960050;background-color:#1e0010"&gt;조건&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;실행문&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;마무리&lt;/span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;연산&lt;/span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;조건을 먼저 평가한 뒤, 참이면 반복을 수행한다.&lt;/li&gt;
&lt;li&gt;반복 전에 조건 검사를 하기 때문에, 조건이 거짓이라면 한 번도 실행되지 않을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조건의 성립 여부&lt;/strong&gt;가 중요한 경우에 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-for문"&gt;2. &lt;code&gt;for&lt;/code&gt;문&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; (i &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; i &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;; i&lt;span style="color:#f92672"&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;실행문&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;초기식, 조건식, 증감식을 한 줄에 모아 작성할 수 있어 반복의 흐름을 한눈에 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;반복 횟수가 명확히 정해져 있을 때 가장 적합하다.&lt;/li&gt;
&lt;li&gt;초기식, 조건식, 증감식은 모두 선택적으로 생략할 수 있으며, &lt;code&gt;for(;;)&lt;/code&gt;는 무한 루프를 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-do-while문"&gt;3. &lt;code&gt;do-while&lt;/code&gt;문&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;실행문&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;} &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (&lt;span style="color:#960050;background-color:#1e0010"&gt;조건&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;먼저 실행문을 &lt;strong&gt;무조건 한 번 실행&lt;/strong&gt;한 뒤, 조건을 검사한다.&lt;/li&gt;
&lt;li&gt;조건이 참이면 다시 반복하고, 거짓이면 종료한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;과 달리 반드시 한 번은 실행된다는 점이 특징이다.&lt;/li&gt;
&lt;li&gt;문법적으로 &lt;code&gt;while(조건)&lt;/code&gt; 뒤에 세미콜론(&lt;code&gt;;&lt;/code&gt;)을 반드시 붙여야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-break와-continue"&gt;4. &lt;code&gt;break&lt;/code&gt;와 &lt;code&gt;continue&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;두 문법 모두 반복문 내에서 흐름을 제어한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="1-break"&gt;(1) &lt;code&gt;break&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;반복문을 즉시 종료하고, 반복문 다음 절차로 이동한다.&lt;/li&gt;
&lt;li&gt;보통 &lt;strong&gt;조건을 만족하면 루프를 탈출&lt;/strong&gt;하는 용도로 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-continue"&gt;(2) &lt;code&gt;continue&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 반복을 중단하고, 반복문의 조건 검사 단계로 돌아가 다음 반복을 수행한다.&lt;/li&gt;
&lt;li&gt;반복 자체를 탈출하는 것이 아니라 &lt;strong&gt;이번 반복만 건너뛴다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;흐름을 복잡하게 만들 수 있으므로, 가급적 단순한 경우에만 사용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="학습-포인트-정리"&gt;학습 포인트 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;while문&lt;/strong&gt;: 조건 중심 반복, 조건이 거짓이면 1회도 실행되지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for문&lt;/strong&gt;: 반복 횟수가 명확할 때 사용하며, 초기식·조건식·증감식이 한 줄에 있어 가독성이 높다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;do-while문&lt;/strong&gt;: 최소 1회 실행이 보장되며, 조건 뒤에 세미콜론이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;break&lt;/strong&gt;는 반복문을 종료하고, &lt;strong&gt;continue&lt;/strong&gt;는 현재 반복만 건너뛰고 다음 반복을 이어간다.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[C언어] 6.제어문</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-6.%EC%A0%9C%EC%96%B4%EB%AC%B8/</link><pubDate>Tue, 23 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-6.%EC%A0%9C%EC%96%B4%EB%AC%B8/</guid><description>&lt;h1 id="c언어-학습-노트--6-제어문"&gt;C언어 학습 노트 : 6. 제어문&lt;/h1&gt;
&lt;h2 id="1-프로그래밍과-제어-구조"&gt;1. 프로그래밍과 제어 구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍은 절차적인 흐름을 논리적으로 작성하는 과정이다.&lt;/li&gt;
&lt;li&gt;일상적인 행위(예: 기상 → 양치 → 식사)에서도 조건에 따라 분기점이 발생한다.&lt;/li&gt;
&lt;li&gt;이러한 분기점을 &lt;strong&gt;제어문(control statement)&lt;/strong&gt; 으로 표현하며, 제어문은 논리적 판단과 조건을 필요로 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-if문"&gt;2. &lt;code&gt;if&lt;/code&gt;문&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조건식의 참/거짓에 따라 분기를 수행하는 가장 기본적인 제어문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;중첩 if문&lt;/strong&gt;은 가독성과 성능 측면에서 불리할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하다면 2분할(else if 구조 등)로 단순화하는 것이 바람직하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단, 현대 CPU와 컴파일러 최적화는 상당히 발달해 있으므로, “성능”보다는 &lt;strong&gt;가독성과 유지보수성&lt;/strong&gt;을 우선적으로 고려하는 것이 좋다.&lt;/p&gt;</description></item><item><title>[C언어] 5.연산자응용</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-5.%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%91%EC%9A%A9/</link><pubDate>Mon, 22 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-5.%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%91%EC%9A%A9/</guid><description>&lt;h1 id="c언어-학습-노트--5-연산자-응용"&gt;C언어 학습 노트 : 5. 연산자 응용&lt;/h1&gt;
&lt;h2 id="1-sizeof-연산자"&gt;1. &lt;code&gt;sizeof&lt;/code&gt; 연산자&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;는 피연산자의 크기를 바이트 단위로 반환한다.&lt;/li&gt;
&lt;li&gt;대부분의 경우 &lt;strong&gt;컴파일 타임&lt;/strong&gt;에 계산되므로 CPU 부하가 발생하지 않는다.&lt;/li&gt;
&lt;li&gt;단, &lt;strong&gt;가변 길이 배열(VLA)&lt;/strong&gt; 의 경우 런타임에 계산이 수행될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof(자료형)&lt;/code&gt; 형태뿐 아니라 &lt;code&gt;sizeof 변수&lt;/code&gt; 형태로도 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;유지보수성을 높여주는 대표적인 연산자이므로 적극 활용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-상등-연산과-부등-연산-부동소수점-비교"&gt;2. 상등 연산과 부등 연산 (부동소수점 비교)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;부동소수점(float, double)은 &lt;strong&gt;근사값&lt;/strong&gt;으로 저장되므로 &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; 비교는 신뢰할 수 없다.&lt;/li&gt;
&lt;li&gt;따라서 직접적인 상등/부등 연산은 권장되지 않는다.&lt;/li&gt;
&lt;li&gt;대소 비교(&lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;)는 가능하나, 여전히 정밀도 문제를 고려해야 한다.&lt;/li&gt;
&lt;li&gt;일반적으로는 &lt;strong&gt;허용 오차(epsilon) 방식&lt;/strong&gt;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;fabs&lt;/span&gt;(a &lt;span style="color:#f92672"&gt;-&lt;/span&gt; b) &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1e-6&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// a와 b는 사실상 같은 값으로 본다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="3-논리-연산자와-short-circuit"&gt;3. 논리 연산자와 Short Circuit&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;논리 연산에서는 필요하지 않은 연산을 생략하는 &lt;strong&gt;단락 평가(short circuit)&lt;/strong&gt; 가 수행된다.&lt;/p&gt;</description></item><item><title>[C언어] 4.연산자기초</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-4.%EC%97%B0%EC%82%B0%EC%9E%90%EA%B8%B0%EC%B4%88/</link><pubDate>Sun, 21 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-4.%EC%97%B0%EC%82%B0%EC%9E%90%EA%B8%B0%EC%B4%88/</guid><description>&lt;h1 id="c언어-학습-노트--4-연산자-기초"&gt;C언어 학습 노트 : 4. 연산자 기초&lt;/h1&gt;
&lt;h2 id="1-대입-연산자-"&gt;1. 대입 연산자 (&lt;code&gt;=&lt;/code&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 복사한다.&lt;/li&gt;
&lt;li&gt;기존 값은 덮어쓰기(overwrite) 되므로, 원래의 값은 보존되지 않는다.&lt;/li&gt;
&lt;li&gt;즉, &lt;code&gt;=&lt;/code&gt; 연산은 &lt;strong&gt;Copy &amp;amp; Overwrite&lt;/strong&gt; 과정임을 반드시 인식해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-l-value와-r-value"&gt;2. l-value와 r-value&lt;/h2&gt;
&lt;h3 id="1-l-value"&gt;(1) l-value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;l-value는 &lt;strong&gt;location value&lt;/strong&gt;의 약어로, 메모리의 주소(위치)를 가리키는 값이다.&lt;/li&gt;
&lt;li&gt;변수는 대표적인 l-value이다.&lt;/li&gt;
&lt;li&gt;l-value는 r-value로 사용할 수 있다. (예: &lt;code&gt;x = y;&lt;/code&gt;에서 &lt;code&gt;y&lt;/code&gt;는 l-value이면서 r-value 역할을 한다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-r-value"&gt;(2) r-value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;r-value는 단순히 값 자체를 의미하며, 메모리 위치를 직접 지정할 수 없다.&lt;/li&gt;
&lt;li&gt;상수나 임시 계산 결과가 r-value에 해당한다.&lt;/li&gt;
&lt;li&gt;r-value는 l-value가 될 수 없다. (예: &lt;code&gt;10 = x;&lt;/code&gt;와 같은 구문은 오류이다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-이형-자료-간-연산"&gt;3. 이형 자료 간 연산&lt;/h2&gt;
&lt;h3 id="1-int--int"&gt;(1) &lt;code&gt;int + int&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;결과는 &lt;code&gt;int&lt;/code&gt;형이다.&lt;/li&gt;
&lt;li&gt;정수 나눗셈을 수행하면 소수점 이하가 절삭되고 몫만 반환된다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;7 / 3&lt;/code&gt;은 &lt;code&gt;2&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-int--double"&gt;(2) &lt;code&gt;int / double&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서로 다른 자료형을 연산할 경우, 범위가 더 넓은 자료형으로 자동 형변환이 일어난다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;int&lt;/code&gt;가 &lt;code&gt;double&lt;/code&gt;로 변환된 후 연산이 수행되어 결과는 &lt;code&gt;double&lt;/code&gt;형이 된다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;7 / 3.0&lt;/code&gt; → &lt;code&gt;2.3333…&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-요약"&gt;4. 요약&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;대입 연산자는 &lt;strong&gt;값을 복사하여 덮어쓰는 연산&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;l-value는 메모리 위치를 의미하며 변수에 해당하고, r-value는 값 자체를 의미한다.&lt;/li&gt;
&lt;li&gt;서로 다른 자료형 연산 시, &lt;strong&gt;범위가 더 넓은 자료형으로 승격(promotion)&lt;/strong&gt; 된다.&lt;/li&gt;
&lt;li&gt;정수 나눗셈에서는 소수점 이하는 절삭되므로, 몫과 나머지를 모두 구하려면 두 번의 연산(&lt;code&gt;/, %&lt;/code&gt;)을 수행해야 한다.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[C언어] 3.표준입출력</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-3.%ED%91%9C%EC%A4%80%EC%9E%85%EC%B6%9C%EB%A0%A5/</link><pubDate>Sat, 20 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-3.%ED%91%9C%EC%A4%80%EC%9E%85%EC%B6%9C%EB%A0%A5/</guid><description>&lt;h1 id="c언어-학습-노트--3-표준-입출력"&gt;C언어 학습 노트 : 3. 표준 입출력&lt;/h1&gt;
&lt;h2 id="1-hci-인간-컴퓨터-상호작용"&gt;1. HCI (인간-컴퓨터 상호작용)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CLI (Command Line Interface)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;텍스트 명령어를 통해 사용자와 컴퓨터가 상호작용하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GUI (Graphical User Interface)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그래픽 요소를 활용하여 사용자와 컴퓨터가 상호작용하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-주요-함수"&gt;2. 주요 함수&lt;/h2&gt;
&lt;h3 id="1-getchar"&gt;(1) &lt;code&gt;getchar()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한 문자를 입력받는 함수이다.&lt;/li&gt;
&lt;li&gt;입력은 버퍼(buffer)를 거쳐 처리된다.&lt;/li&gt;
&lt;li&gt;버퍼가 비어 있으면 입력을 기다리고, 버퍼에 데이터가 있으면 첫 번째 문자 하나만 반환한다.&lt;/li&gt;
&lt;li&gt;반환값은 &lt;code&gt;int&lt;/code&gt;형으로, &lt;code&gt;EOF&lt;/code&gt; 처리를 위해 &lt;code&gt;char&lt;/code&gt;가 아닌 &lt;code&gt;int&lt;/code&gt;로 정의된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;printf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;문자를 입력하세요: &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getchar&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;printf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;입력한 문자: %c&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;, c);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id="2-scanf"&gt;(2) &lt;code&gt;scanf()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서식 지정자(format specifier)에 맞추어 입력을 받는 함수이다.&lt;/p&gt;</description></item><item><title>[C언어] 2.자료형</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-2.%EC%9E%90%EB%A3%8C%ED%98%95/</link><pubDate>Fri, 19 Jan 2024 22:54:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-2.%EC%9E%90%EB%A3%8C%ED%98%95/</guid><description>&lt;h1 id="c언어-학습-노트--자료형-정리"&gt;C언어 학습 노트 : 자료형 정리&lt;/h1&gt;
&lt;h2 id="1-정수형-자료형"&gt;1. 정수형 자료형&lt;/h2&gt;
&lt;h3 id="1-int"&gt;(1) &lt;code&gt;int&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32비트 체계에서 일반적으로 4바이트(32비트)를 차지한다.&lt;/li&gt;
&lt;li&gt;표현 범위는 약 -2,147,483,648 ~ 2,147,483,647이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-long-long-int"&gt;(2) &lt;code&gt;long long int&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;64비트 정수형으로, 8바이트(64비트)를 차지한다.&lt;/li&gt;
&lt;li&gt;표현 범위는 약 -9 × 10¹⁸ ~ 9 × 10¹⁸이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-부호signedunsigned"&gt;(3) 부호(signed/unsigned)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;signed&lt;/strong&gt; : 부호 비트가 존재하여 양수와 음수를 모두 표현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsigned&lt;/strong&gt; : 부호 비트가 없으며, 0 이상의 정수만 표현한다.
→ 같은 크기의 메모리를 사용할 경우, unsigned 형식이 더 큰 양수 범위를 표현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-문자열"&gt;2. 문자열&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문자열은 문자들의 연속이며, 마지막에 &lt;strong&gt;NULL 문자(&lt;code&gt;'\0'&lt;/code&gt;)&lt;/strong&gt; 로 끝을 표시한다.&lt;/li&gt;
&lt;li&gt;문자열을 다룰 때는 NULL 문자를 포함한 크기를 반드시 고려해야 한다.
예를 들어, 14글자를 저장하려면 15칸의 메모리를 확보해야 한다.&lt;/li&gt;
&lt;li&gt;문자열 처리 시에는 메모리 구조와 NULL 종료 규칙을 정확히 이해해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-부동소수점-자료형"&gt;3. 부동소수점 자료형&lt;/h2&gt;
&lt;h3 id="1-float"&gt;(1) &lt;code&gt;float&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단정도(single precision) 부동소수점&lt;/li&gt;
&lt;li&gt;4바이트(32비트) 크기&lt;/li&gt;
&lt;li&gt;유효 자릿수: 약 6자리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-double"&gt;(2) &lt;code&gt;double&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배정도(double precision) 부동소수점&lt;/li&gt;
&lt;li&gt;8바이트(64비트) 크기&lt;/li&gt;
&lt;li&gt;유효 자릿수: 약 15자리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-long-double"&gt;(3) &lt;code&gt;long double&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;특수 정밀도(extended precision) 부동소수점&lt;/li&gt;
&lt;li&gt;일부 컴파일러에서는 80비트(79비트 이상) 지원&lt;/li&gt;
&lt;li&gt;컴파일러와 아키텍처에 따라 지원 여부와 크기가 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4-실수의-오차-문제"&gt;(4) 실수의 오차 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터에서 실수(real number)는 근사값으로 저장되므로 오차가 발생한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;는 정밀도가 낮아 계산 시 오차가 커질 수 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 &lt;code&gt;double&lt;/code&gt;을 사용하는 것이 안전하다. 단, &lt;code&gt;double&lt;/code&gt; 역시 약 15자리까지만 정확하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="4-입출력-시-주의사항"&gt;4. 입출력 시 주의사항&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;printf()&lt;/code&gt;에서는 &lt;code&gt;%f&lt;/code&gt;를 사용하면 &lt;code&gt;float&lt;/code&gt;과 &lt;code&gt;double&lt;/code&gt; 모두 출력 가능하다.&lt;/p&gt;</description></item><item><title>[C언어] 1.기초</title><link>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-1.%EA%B8%B0%EC%B4%88/</link><pubDate>Thu, 18 Jan 2024 22:42:37 +0900</pubDate><guid>https://goldtg.github.io/posts/c%EC%96%B8%EC%96%B4-1.%EA%B8%B0%EC%B4%88/</guid><description>&lt;h1 id="c언어-학습-정리"&gt;C언어 학습 정리&lt;/h1&gt;
&lt;h2 id="1-c언어의-기원"&gt;1. C언어의 기원&lt;/h2&gt;
&lt;p&gt;프로그래밍 언어 C는 데니스 리치(Dennis Ritchie)에 의해 창시되었다.
초기의 UNIX 운영체제는 B 언어로 작성되었으나, 이후 C 언어로 재작성되면서 그 활용 범위가 크게 확장되었다.&lt;/p&gt;
&lt;p&gt;B 언어와 C 언어의 주요 차이는 &lt;strong&gt;자료형(type system)&lt;/strong&gt; 의 도입 여부이다.
B 언어는 typeless 언어에 가까워 모든 데이터를 단일 word 단위로 처리하였으나,
C 언어는 정교한 자료형 체계와 포인터, 배열, 구조체 등을 지원함으로써 시스템 프로그래밍 언어로서의 기반을 확립하였다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-c-프로그램의-기본-구조"&gt;2. C 프로그램의 기본 구조&lt;/h2&gt;
&lt;p&gt;다음 예제는 가장 단순한 형태의 C 프로그램이다.&lt;/p&gt;</description></item></channel></rss>